## 如何运行

mvn spring-boot:run
访问 http://localhost:8080

## 问题复现步骤
1. 点击"执行任务（问题模式）"按钮
- 这会提交3个任务到只有2个线程的公共线程池
- 由于线程池只有2个线程，第三个任务会排队等待
2. 在任务执行期间（约5秒），快速点击"检查服务状态"按钮
- 由于Tomcat工作线程被阻塞在cf.get()上
- 服务可能无法响应新请求，或者响应非常慢
3. 观察结果：
- 服务状态检查可能超时或失败
- 控制台会显示线程阻塞和排队情况

## 解决方案演示
1. 点击"执行任务（解决方案）"按钮
这会提交3个任务到自定义线程池
自定义线程池足够处理这些任务
2. 在任务执行期间，点击"检查服务状态"按钮
Tomcat工作线程没有被阻塞
服务能够正常响应新请求

## 关键学习点
1. 问题根源：
使用公共线程池（ForkJoinPool.commonPool()）时，其大小有限
当线程池满时，新任务排队
cf.get()会阻塞Tomcat工作线程
阻塞的工作线程无法处理新请求

2. 解决方案：
使用自定义线程池，根据业务需求配置合适的大小
为阻塞操作设置超时时间（如cf.get(10, TimeUnit.SECONDS)）
避免在Tomcat工作线程中执行长时间阻塞操作
考虑使用异步非阻塞编程模型

## 学习要点
通过这个项目，你可以学习到：

1.公共线程池（ForkJoinPool.commonPool()）的局限性

2.阻塞操作（cf.get()）对Tomcat工作线程的影响

3.线程池耗尽导致的服务不可用问题

4.使用自定义线程池的解决方案

5.线程池配置的最佳实践

6.超时机制在并发编程中的重要性

7.TTL（TransmittableThreadLocal）解决线程池上下文传递问题